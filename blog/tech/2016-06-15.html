<time>2016-06-15</time>
<tit>链表读取、排序等</tit>


<article>
<p>
<!-- <h3>抱歉，文章发现错误内容，更改中</h3> -->
之前说道了怎么创建单向链表，这里将介绍如何处理已经创建好的链表。包括读取、添加、删除、排序等。<br>Ok，
进入正题：
</p>
<center>正题</center>
<hr>
<h3>获取链表的头：</h3>
<p>前面已经创建好了一个链表，要对它操作，我们就要获取其中的某个节点，因为是单向链表，似乎只有链表的头（只有next指针会指向相邻的一个结构体）才可以帮助我们获取整个链表的信息。</p>
<p>这里介绍一种我常用的方法。代码暂且不贴，口述即可。<br><br>
记得我们在前面创建的CreateLinkList()函数吧，现在在函数里面加上形参改为CreatLinkList(INFO *head)。再函数第一次申请内存块的时候，把head指针指向该内存块头部即可。那么，我们只需在要调用CreatLinkList()函数的地方，在之前申明INFO *head;即可。<br><br>
当然，在原本的CreatLinkList()函数里面申明INFO *head;再把head指向第一次申请的内存块头部，在最后返回head也可以（return head；）。记得把函数申明为INFO *CreatLinkList();
</p>
<p>Ok,有办法获取单向链表的头那么接下来就好办了。</p>
<hr>
<h3>添加、删除：</h3>
<p>读取内容在你知道表头的情况下就很简单了吧，这里应该不需要我再赘述了。如果需要了解的话，这一段当然还是会有的啦。</p>
<p>主要介绍如何添加数据，还是代码块优先：</p>
<pre>
void AddInfo(INFO *head , unsigned int *order)
{
	INFO *temp,*ins;
	unsigned int n=1;
	temp=head;
	while(order > n)
	{
		temp=temp->next;	//移动节点的指向指针
		n++;
	}
	if((ins=(INFO *)malloc(sizeof(INFO)))==NULL)
	{
	//内存申请失败，处理措施
	}
	gets(ins->data);
	ins->next=temp->next;	//插入节点的next成员指向当前节点的下一个节点
	temp->next=ins;			//当前节点的next成员指向插入节点
}
</pre>
<p>OK，到此向链表中插入一个节点的工作就算完成了。至于如何删除节点，应该就容易明白了吧。<br>把要删除的节点的前一个节点的next成员指向要删除节点的下一个节点就好了（有点绕...）。为了结构优美一点，把要删除的节点的next置为NULL是挺不错的。</p>
<p>据此，各位就可以用某个节点的数据为判断依据，决定是否要保留（替换）这个节点。</p>
<center>我是分割线</center>
<hr>
<h3>链表的排序：</h3>
<p>
任然代码优先：
</p>
<pre>
void Sorted(INFO *head)
{
INFO temp,*p,*q;
for(p=head;p->next!=NULL;p=p->next)
	for(q=p;q->next!=NULL;q=q->next)
		{
			if(strcmp(p->data,q->data)>0)
				{
				temp=*p;
				*p=*q;
				*q=temp;
				}
		}
}
</pre>
（还未测试）
<p>插入排序，一看就容易理解了吧。当然，更优秀的算法也有。</p>
<center>题外话</center>
<hr>
<p>
这些天写的东西都要有最基础的准备。至于类似for循环啊、if啊等等，这些实在没必要写了。需要的话，相信你一天就可以看完了，而且也没什么可以讲的。个人认为，这些东西对于初学者都不是很好理解的，没关系。看一次还不能理解的话，我的目的就达到了；看一次就懂得话，是我太菜了~~~学习编程这东西，最好不要是让别人完全嚼烂了再学吧。多多自己分析分析！！！<br>
总结为：理解+自我实践<br>
以上为个人愚见
</p>
<p>实际上，关于这个排序问题，一直都有纠结的地方；不过这段时间可能更新的进度不会快，待有好的想法或解决办法时会继续更新
</article>


<tag><part>链表</part> <part>内容处理</part> <part>排序</part></tag>
<more>./blog/tech/2016-06-15.html</more>